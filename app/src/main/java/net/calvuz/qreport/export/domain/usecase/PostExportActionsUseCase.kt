package net.calvuz.qreport.export.domain.usecase

import android.content.Context
import android.content.Intent
import android.os.Environment
import androidx.core.content.FileProvider
import dagger.hilt.android.qualifiers.ApplicationContext
import net.calvuz.qreport.app.error.domain.model.QrError
import net.calvuz.qreport.app.result.domain.QrResult
import net.calvuz.qreport.export.domain.reposirory.ExportFileRepository
import net.calvuz.qreport.export.domain.reposirory.ExportFormat
import net.calvuz.qreport.export.domain.reposirory.MultiFormatExportResult
import net.calvuz.qreport.share.domain.repository.QReportMimeTypes
import timber.log.Timber
import java.io.File
import javax.inject.Inject

/**
 * Use case for post-export actions: Open or Share
 */
class PostExportActionsUseCase @Inject constructor(
    @ApplicationContext private val context: Context,
    private val exportFileRepository: ExportFileRepository
) {

    /**
     * Copy export to Documents/QReport and open with default app
     */
    suspend fun openExport(exportResult: MultiFormatExportResult): QrResult<String, QrError> {
        return try {
            Timber.d("Opening export from: ${exportResult.exportDirectory}")

            // 1. Copy to Documents/QReport
            val publicPath = copyToDocuments(exportResult)

            // 2. Open main file with default app
            when (val mainFileResult = getMainExportFile(publicPath, exportResult)) {
                is QrResult.Error -> return mainFileResult
                is QrResult.Success -> {
                    val mainFile = File(mainFileResult.data)
                    openFileWithDefaultApp(mainFile)

                    Timber.d("Export opened from: ${mainFile.absolutePath}")
                    QrResult.Success(publicPath)
                }
            }

        } catch (e: Exception) {
            Timber.e(e, "Failed to open export")
            QrResult.Error(QrError.FileError.FILE_READ)
        }
    }

    /**
     * Share export using Android share intent
     */
    suspend fun shareExport(exportResult: MultiFormatExportResult): QrResult<Unit, QrError> {
        return try {
            Timber.d("Sharing export from: ${exportResult.exportDirectory}")

            // 1. Get main file from internal storage
            when (val mainFileResult = getMainExportFile(exportResult.exportDirectory!!, exportResult)) {
                is QrResult.Error -> return QrResult.Error(mainFileResult.error)
                is QrResult.Success -> {
                    val mainFile = File(mainFileResult.data)

                    // 2. Create FileProvider URI
                    val fileUri = FileProvider.getUriForFile(
                        context,
                        "net.calvuz.qreport.fileprovider",
                        mainFile
                    )

                    // 3. Create share intent
                    val shareIntent = Intent(Intent.ACTION_SEND).apply {
                        type = getMainFormat(exportResult).mimeType
                        putExtra(Intent.EXTRA_STREAM, fileUri)
                        putExtra(Intent.EXTRA_SUBJECT, "QReport Export")
                        putExtra(Intent.EXTRA_TEXT, "Export generated by QReport")
                        addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }

                    // 4. Start share chooser
                    val chooserIntent = Intent.createChooser(shareIntent, "Share Export")
                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)

                    context.startActivity(chooserIntent)

                    Timber.d("Export shared: ${mainFile.name}")
                    QrResult.Success(Unit)
                }
            }

        } catch (e: Exception) {
            Timber.e(e, "Failed to share export")
            QrResult.Error(QrError.ExportError.FILE_SHARE_FAILED)
        }
    }

    // ===== PRIVATE HELPERS =====

    /**
     * Copy export directory to Documents/QReport
     */
    private fun copyToDocuments(exportResult: MultiFormatExportResult): String {
        val documentsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS)
        val qreportDir = File(documentsDir, "QReport").apply { mkdirs() }

        val sourceDir = File(exportResult.exportDirectory!!)
        val targetDir = File(qreportDir, sourceDir.name)

        // Copy recursively with overwrite
        sourceDir.copyRecursively(targetDir, overwrite = true)

        Timber.d("Export copied to: ${targetDir.absolutePath}")
        return targetDir.absolutePath
    }

    /**
     * Get main export file from directory
     */
    private suspend fun getMainExportFile(
        exportPath: String,
        exportResult: MultiFormatExportResult
    ): QrResult<String, QrError> {
        // Priority: Word > Text > Photos
        return when {
            exportResult.wordResult != null -> {
                val wordDir = File(exportPath, "word")
                val wordFile = wordDir.listFiles()?.firstOrNull { it.extension ==
                        QReportMimeTypes.WORD
                }
                wordFile?.let { QrResult.Success(it.absolutePath) }
                    ?: QrResult.Error(QrError.FileError.FILE_NOT_FOUND)
            }
            exportResult.textResult != null -> {
                val textDir = File(exportPath, "text")
                val textFile = textDir.listFiles()?.firstOrNull { it.extension ==
                        QReportMimeTypes.TEXT
                }
                textFile?.let { QrResult.Success(it.absolutePath) }
                    ?: QrResult.Error(QrError.FileError.FILE_NOT_FOUND)
            }
            // TODO: Aggiungere support per foto
            exportResult.photoFolderResult != null -> {
                val photosDir = File(exportPath, "photos")
                // Create a ZIP of photos if not exists
                val zipFile = File(exportPath, "photos.zip")
                if (!zipFile.exists()) {
                    // Use exportFileRepository to create ZIP
                    // For now, return photos directory
                    QrResult.Success(photosDir.absolutePath)
                } else {
                    QrResult.Success(zipFile.absolutePath)
                }
            }
            else -> QrResult.Error(QrError.FileError.FILE_NOT_FOUND)
        }
    }

    /**
     * Get main format from export result
     */
    private fun getMainFormat(exportResult: MultiFormatExportResult): ExportFormat {
        return when {
            exportResult.wordResult != null -> ExportFormat.WORD
            exportResult.textResult != null -> ExportFormat.TEXT
            exportResult.photoFolderResult != null -> ExportFormat.PHOTO_FOLDER
            else -> ExportFormat.TEXT
        }
    }

    /**
     * Open file with default app
     */
    private fun openFileWithDefaultApp(file: File) {
        val fileUri = FileProvider.getUriForFile(
            context,
            "net.calvuz.qreport.fileprovider",
            file
        )
        val fileExtension = file.extension.lowercase()
        val extension = QReportMimeTypes.forExtension(fileExtension)

        Timber.d ("Opening file with default app {file=$fileUri, fileExtension=$fileExtension, extension=$extension}")

        val openIntent = Intent(Intent.ACTION_VIEW).apply {
            setDataAndType(fileUri, extension)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }

        context.startActivity(openIntent)
    }

    /**
     * Get MIME type from file extension
     */
    private fun getMimeType(file: File): String {
        QReportMimeTypes
        return when (file.extension.lowercase()) {
            "docx" -> "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            "txt" -> "text/plain"
            "zip" -> "application/zip"
            "pdf" -> "application/pdf"
            else -> "application/octet-stream"
        }
    }
}